{"version":3,"sources":["../src/IPC/ClusterIPC.ts"],"names":[],"mappings":"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","file":"ClusterIPC.js","sourcesContent":["import { EventEmitter } from 'events';\r\nimport { Client as VezaClient, NodeMessage, ClientSocket } from 'veza';\r\nimport { Client, Util } from 'discord.js';\r\nimport { IPCEvents } from '../Util/Constants';\r\nimport { IPCResult } from '..';\r\nimport { IPCError } from '../Sharding/ShardClientUtil';\r\n\r\nexport interface IPCRequest {\r\n\top: number;\r\n\td: string;\r\n}\r\n\r\nexport class ClusterIPC extends EventEmitter {\r\n\tpublic clientSocket?: ClientSocket;\r\n\tpublic client: Client;\r\n\tpublic node: VezaClient;\r\n\r\n\tpublic constructor(discordClient: Client, public id: number, public socket: string | number) {\r\n\t\tsuper();\r\n\t\tthis.client = discordClient;\r\n\t\tthis.node = new VezaClient(`Cluster ${this.id}`)\r\n\t\t\t.on('error', error => this.emit('error', error))\r\n\t\t\t.on('disconnect', client => this.emit('warn', `[IPC] Disconnected from ${client.name}`))\r\n\t\t\t.on('ready', client => this.emit('debug', `[IPC] Connected to: ${client.name}`))\r\n\t\t\t.on('message', this._message.bind(this));\r\n\t}\r\n\r\n\tpublic async broadcast(script: string | Function) {\r\n\t\tscript = typeof script === 'function' ? `(${script})(this)` : script;\r\n\t\tconst { success, d } = await this.server.send({ op: IPCEvents.BROADCAST, d: script }) as IPCResult;\r\n\t\tif (!success) throw Util.makeError(d as IPCError);\r\n\t\treturn d as unknown[];\r\n\t}\r\n\r\n\tpublic async masterEval(script: string | Function) {\r\n\t\tscript = typeof script === 'function' ? `(${script})(this)` : script;\r\n\t\tconst { success, d } = await this.server.send({ op: IPCEvents.MASTEREVAL, d: script }) as IPCResult;\r\n\t\tif (!success) throw Util.makeError(d as IPCError);\r\n\t\treturn d;\r\n\t}\r\n\r\n\tpublic async init() {\r\n\t\tthis.clientSocket = await this.node.connectTo(String(this.socket));\r\n\t}\r\n\r\n\tpublic get server() {\r\n\t\treturn this.clientSocket!;\r\n\t}\r\n\r\n\tprivate _eval(script: string): string {\r\n\t\treturn (this.client as any)._eval(script);\r\n\t}\r\n\r\n\tprivate async _message(message: NodeMessage) {\r\n\t\tconst { op, d } = message.data;\r\n\t\tif (op === IPCEvents.EVAL) {\r\n\t\t\ttry {\r\n\t\t\t\tmessage.reply({ success: true, d: await this._eval(d) });\r\n\t\t\t} catch (error) {\r\n\t\t\t\tmessage.reply({ success: false, d: { name: error.name, message: error.message, stack: error.stack } });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"],"sourceRoot":"../../src"}